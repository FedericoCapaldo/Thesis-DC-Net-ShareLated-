\chapter{Evaluation}
This chapter contains a personal reflection on the implemented protocol. 

CAMBIA: to present its strength, to assess its contribution to academia,  and weaknesses, to identify possible areas of improvement. 

\section{Assessment on the implementation against the requirements}
The simulation implemented met all the basic requirements and advanced requirements outlined in section \ref{sec:requirements}. Not only the simulation performs the core multi-party XOR computation of three entities, but it also acknowledges several limitations proposing solutions to each one:
\begin{itemize}
    \item message collisions are detected;
    \item the communication occurs in different types of rounds (voting, length calculation and communication) so as to send longer messages;
    \item I adopt ASCII encoding to translate the result of communication rounds into letters so as to communicate human-readable messages;
    \item any number of participants can join or leave the network during the protocol execution without affecting the correctness of the messages exchanged;
\end{itemize}
All of the above takes place with an actual distributed architecture and using a graphical user interface.

I, therefore, consider this a satisfactory implementation.


\section{Comparison of simulation with other works}
Relative to the other implementations found online, my simulation tool implemented proposes some additions that the improve the state of the art of Dining Cryptographer simulated implementations. The main contributions are:
\begin{enumerate}
    \item \textbf{User-experience:} while current tools generally present difficult installation, I provide an easier user experience readily available online. Moreover, the user interface is improved. Current tools mostly offer a command-line interface, which requires the user to \textit{memorise} verbose commands. The user experience provided is, instead, more intuitive with the use of a GUI, which only requires to \textit{recognize} visual cues like buttons and colors. Plus, the simulation is equipped with a number of descriptive messages about what is happening during the execution of the protocol;
    \item \textbf{Documentation}: Tools found provide incomplete or unusable documentation, which may be especially important in understanding a command-line software. The implementation achieved has no remarkable learning barrier but, if needed, a visual user guide is provided (see Appendix \ref{appendix:userGuide});
    \item \textbf{Distributed architecture}: all tools found run locally on a single machine. The simulation implemented offers a realistic experience through the website, since it allows users to connect to the server from different physical locations.
\end{enumerate}

On the whole, this number of improvements move the current state of art forward and enables cryptography enthusiasts learn in a practical way the potential of this protocol.

\section{Known limitations of the implemented solution}
Despite the advancements achieved, there is a number of known limitations to be acknowledged. 

\subsection{Key Exchange}
Since the software has been developed as a web application, the standard effective way to secure a line of communication on the Internet is to channel all requests through \lstinline{https} protocol. This provides a solution to exchange keys securely, however it does not address the problem of key exchange at a protocol level. Therefore, if this simulation was to be implemented as a desktop application the problem of key-exchange would have to be addressed in another way such as one of the techniques listed in section \ref{sec:keyExchangeMethods}.

\subsection{Presence of Server} \label{sec:evalServerPresence}
Making use of a client-server architecture introduces the server which represents the DC-Net Service. This raises the issue of trusting that the server, or who manages it, does not misuse his comprehensive view of the network as discussed in section \ref{sec:clientserver}. Since this is a web application, the use of a SSL certificate would verify the server's identify but a client using the this platform cannot know how the server handles the responses sent to it. The client-server architecture was chosen putting emphasis on the fact that this is a simulation. Specifically, it was selected because the presence of a centralised service allows the implementation of some advanced features. For example, it would not be possible to detect collisions without an entity that is able to see all the messages in a round. Therefore, there was a design choice to be made between the useful but questionable presence of an omniscient principal, the server, and the choice of a serverless architecture, as described in \cite{Scholz}, with more limited capabilities. Therefore, both the choice taken and its counterpart present some limitations.

\subsection{Collusion}
A real-world aspect not addressed in the current implementation is the possible collusion of malicious participants inside the network. In fact, these attackers can join forces and pool their keys together in order to uncover who the real sender is, as explained in section \ref{sec:disruptionlimitation}.

\subsection{Anonymity Reduction due to collision detection warnings} \label{sec:anonymityReductionLimitation}
In the final implementation, which also includes the advanced requirements, the communication is divided in three types of round (voting, length calculation, communication rounds) as presented in section \ref{sec:advancedReq}. During the voting round each participant can express his intention to send a message. If the client tries to win the voting round, he locally declares himself message sender for that round on his browsers, and he believes so unless the server will send a message rejection notification back. This mechanism is employed so as to avoid sending a unicast notification to the message sender who won the voting round, which would obviously uncover who the message sender is to a potential eavesdropper. However, it is assumed that an eavesdropped can even intercept the notifications of message rejection. Hence, an external observer that listens in every message from and to the DC-Net Service can deduct that none of the clients that received a rejection is the real message sender during this round. Therefore, the anonymity set is reduced to those participants that have not received such notification.

The reality is that there is no easy solution to avoid this reduction in the degree of anonymity. Hypothetically ,if the user-experience would not be a priority, the server could simply drop the unsuccessful attempts to win the voting round without sending a warning message of rejection back. However, there must still be an update of state of the client's browser to change their self-declared belief of being the sender, and this can come only from the server.

\subsection{Edge case of anonymity impairment due to collision detection warning} \label{sec:anonymityImpairmentEdgeCase}
Due to the needed feature of message rejection in the voting round, there exists an edge case where an eavesdropper inside the network can impair the internal untraceability of a round. The scenario presents three cryptographers, in which there are:
\begin{enumerate}
    \item a message sender who won the voting round;
    \item a second participant that tried to win the voting round;
    \item the internal eavesdropped that can listen in to all communication from and to the server.
\end{enumerate}
It follows that since there are only two other clients, a message sender and one client that received a rejection notification, then the eavesdropper knows that the message sender obviously is the client who did not receive a rejection.

In this case, anonymity is internally lost and only 'preserved' in respect to an external observer, assuming that such observer is not colluding with the internal eavesdropper.


\section{Disparity between Protocol Perfection and Real World Implementation}
The main goal of the project was to create a simulation tool for the Dining Cryptographers protocol. In addition to that however, there is an important benefit that follows the effort of practically implementing a theoretical protocol. Specifically, this is the valuable analysis that is obtained by overcoming of all the complications that arise during each step of development. In other words, there exists an evident gap between reasoning about a security protocol in the abstract and actually deploying a working solution that holds the desired security properties and preserves correctness at all times.

Throughout the implementation of the DC-Net such fact has been demonstrated in a number of instances. This derived analysis is of significant importance because the wealth of academic papers available about the Dining Cryptographers focus almost entirely on the theoretical considerations of the protocol. The following sections explain the unforeseen important challenges that arose throughout the implementation. These are a valuable observation of the work performed.

\subsection{Implications of design decisions of key-exchange graph topology and network topology}
In the Background chapter, it was articulated what are the different choices in terms of key-exchange graph topology (section \ref{sec:keyExchangeMethods}) and network topology (section \ref{sec:networkTopologies}). Each choice has different requirements and implication to be implemented. For the simulation presented, the design choices where made with a focus on being explicative of the protocol without being too strict about the complete correctness of the protocol.

A theoretical discussion of the DC-Net takes in consideration only of the the advantages and disadvantages of the key-exchange graph, already presented in section \ref{sec:participantsextention}. In a realistic implementation instead is also important to decide the network topology to be used. The two topologies are independent from each other, but the choice of each topology will impact the total overhead of sending a single message.

Furthermore, as this is a security protocol there are some concerns raised in respect to a client-server topology due to the presence of the server. This entails various considerations and tradeoffs as presented in sections \ref{sec:clientserver} and \ref{sec:evalServerPresence}.

\subsection{Correctness of protocol on client connection during protocol execution}
The theoretical protocol is presented with cryptographers at the table or vertices in a graph. In an actual implementation there is the process of sitting down at the table or joining the graph. More simply, there is a connection event for each client to the DC-Net Service. 

Adding a participant to the graph implies updating the adjacencies of the graph, i.e. the secret keys between clients. If a connection of an $nth$ client happens when the protocol started its execution and some, but not all, participants already provided their response for the round, then performing an update of adjacencies at this stage would create a mismatch of state between the clients and the server. More specifically, after the keys update, the combination of old responses recorder by the server in conjunction with the missing responses of that will now be provided to the server will not XOR each other out, therefore affecting the correctness of the protocol.

Thus, the simulations employs a waiting mechanism for clients that join the network in the midst of the protocol execution to delay their participation until the next voting round.

\subsection{Correctness of protocol on client disconnections}
Another important, non-trivial problem not addressed by a conceptual protocol study is the event of disconnection of a user while the protocol is happening. A client abandoning the network after the key-exchange phase in any of the voting, length-calculation, or communication rounds undermines the correctness of the final result since the response of the client who just disconnected will be missing in the server's final round calculation. This is due to some of the keys not being XORed twice, which is fundamental to reveal the broadcasted hidden round message (an ASCII character) sent by the anonymous message sender (see section \ref{sec:xorDemonstration}).

The immediate solution is to, again, update the adjacencies when a client disconnects and, if necessary, stop and restart the round. However, in a network with several clients, such mechanism would affect the user experience and serviceability of the protocol, also allowing a malicious participant to harm the availability of the service by simply connecting and disconnecting to the service repeatedly.

It is in these circumstances that the presence of the DC-Net service is valuable. That is, when a disconnection happens, the server, that keeps track of all of the adjacencies' keys will simply update update the two relevant adjacency objects and their respective keys, without interrupting the round in progress.

\subsection{Edge cases that compromise untraceability}
The theoretical exposition acknowledges the core communication steps that need to happen during a smooth round of communication. However, in a real world scenario it is very likely that more messages or events are communicated between a client and the server. For instance, at the end of a round the clients is notified to remove their message sender state if they sent a message.  Although this example does not affect the senders or recipients untraceability, it is important to carefully plan the introduction of any such communication between clients and server. A relevant case is instead the message rejection notification, extensively discussed in sections \ref{sec:anonymityReductionLimitation} and \ref{sec:anonymityImpairmentEdgeCase}, which affect the degree of untraceability.  

Therefore, guaranteeing untraceability for all edge cases in the implementation is more laborious than ensuring the perfection of the cryptographic algorithm at a theoretical level.


\subsection{Necessity of a length-calculation round}
A proposal to extend the protocol in multiple rounds is offered in different works. This divides communication in a voting phase and a actual sending phase. This approach was also chosen for the simulated implementation so that long sentences can be communicated without interruption. With the presence of the DC-Net as the entity that generate the secret keys in bulk to be transmitted, the length of the message is to be known so as to generate the same number of keys as the number of characters present in the message. Though, if the message sender will calculate the length of his message on his browser and send it directly to the server, an eavesdropped would trivially identify him as the sender. Therefore, the implementation demands an intermediate step between voting and communication rounds, namely the length calculation round. This happens so that all clients receive two long keys and automatically send to the server a dummy response, giving the opportunity to the message sender to XOR the length of his message with his keys.


\subsection{Difficulty of ensuring fair use of network}
Another form of attack that does not weaken untraceability but affects the availability of the service is the hogging of the network bandwidth. This happens when a participant tries to continuously win the voting round. The solution implemented prevents the message sender from winning the next round, so that an individual attacker cannot hog the message sending space more than half of the time. 

However, the ideal solution to ensure authentic fairness usage of the ability to send a message would be to implement a queue. This data structure would be located on the server-side to record the order in which users tried to send a message, and give a possibility to do so in the next upcoming rounds. However, this is a very fiddly feature to implement due to intricate possible scenarios. 

An exemplification of this is the following: there are at least two cryptographers in the sending queue who tried to win the voting round simultaneously. At the start of the new round the user at the front of the queue is asked if he would still like to send a message. The first issue raised is that this question cannot be a unicast message between the client and the server. Otherwise if after this communication the length-calculation round happens, it would be obvious who the sender is. Therefore, to maintain untraceability this question would require a further type of broadcast round. 

Furthermore, there are particular edge cases to be addressed. For example, what happens if the cryptographer, front of the queue, accepted to send a message but then disconnects? It is likely that that the same offer of sending a message should be made to the new first user in the queue, having to repeat another broadcast round just to ask this. Hence, the queue may risk to make the protocol to revolve several rounds around the voting phase. This is the completely counterproductive since it could affect the availability of the service ,which was the issue that the queue set out to solve in the first place. 

This is an excellent instance of how an implementation can get highly difficult rather quickly. \newline \newline




Ultimately, all these various exemplifications of differences between a theoretical protocol and an effective application illustrated the constructive knowledge gained along the hands-on development phase. The purely theoretical argumentation of the protocol presented in many papers rarely offer an appreciation of these practical complex challenges. Hence, these were important remarks to be addressed as a contribution to the academic community.

